<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wahlkampf Runner – FDP Coins sammeln</title>
  <style>
    body {
      font-family: Calibri, sans-serif;
      background-color: #f0f8ff;
      color: #333;
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      user-select: none;
    }
    header {
      background-color: #009ee3;
      color: #fff;
      padding: 20px 10px;
      text-align: center;
      font-weight: bold;
      font-size: 1.5rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    main {
      flex: 1;
      padding: 20px;
      max-width: 760px;
      margin: 0 auto;
      width: 100%;
      text-align: center;
      position: relative;
    }
    h2 {
      margin-top: 60px;
      color: #009ee3;
    }
    canvas {
      border: 2px solid #009ee3;
      background: #fff;
      display: block;
      margin: 20px auto;
      max-width: 100%;
      height: auto;
    }
    #buttonsContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-bottom: 30px;
    }
    button#jumpBtn {
      background-color: #009ee3;
      color: #fff;
      border: none;
      padding: 12px 30px;
      font-family: Calibri, sans-serif;
      font-weight: bold;
      font-size: 1.1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.1s ease;
      min-width: 140px;
      user-select: none;
    }
    button#jumpBtn:active {
      background-color: #ffed00;
      color: #000;
      transform: scale(0.95);
    }
    button#homeBtn {
      background-color: #e5007d;
      color: #fff;
      border: none;
      padding: 12px 24px;
      font-family: Calibri, sans-serif;
      font-weight: bold;
      font-size: 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      min-width: 160px;
      user-select: none;
    }
    button#homeBtn:hover {
      background-color: #c00066;
    }
    #arrowButtons {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 20px;
    }
    button.arrowBtn {
  background-color: #009ee3;  /* hellblau */
  color: #fff;
  border: none;
  padding: 12px 28px;
  font-family: Calibri, sans-serif;
  font-weight: bold;
  font-size: 1.5rem;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.1s ease;
  width: 100px;
  height: 50px;
  line-height: 1;
  user-select: none;
}

button.arrowBtn:active {
  background-color: #ffed00; /* gelb beim Klicken */
  color: #000;
  transform: scale(0.95);
}
    #restartBtn {
      display: none;
      background:#009ee3;
      color:#fff;
      padding:12px 30px;
      margin-top:10px;
      font-family: Calibri, sans-serif;
      font-weight: bold;
      font-size: 1.1rem;
      border-radius: 5px;
      cursor: pointer;
      user-select: none;
      border: none;
    }
    #restartBtn:hover {
      background-color: #007bbf;
    }
#gameOverText {
  position: fixed;            /* bleibt auf dem Bildschirm sichtbar */
  top: 50%;
  left: 0;                    /* Start ganz links */
  transform: translateY(-50%);/* nur vertikal zentrieren */
  width: 100vw;               /* 100% der Viewport-Breite */
  background: rgba(255, 255, 255, 0.95);
  padding: 30px 0;            /* oben/unten Abstand, kein links/rechts */
  border-top: 3px solid #e5007d;
  border-bottom: 3px solid #e5007d;
  color: #e5007d;
  font-size: 1.8rem;
  font-weight: bold;
  display: none;
  user-select: none;
  z-index: 10;
  font-family: Calibri, sans-serif;
  line-height: 1.4;
  text-align: center;         /* zentriert den Text */
  box-sizing: border-box;     /* padding wird zur Gesamtbreite gezählt */
}

#gameOverText .textRow {
  display: none;
  flex-direction: row;
  gap: 30px;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap; /* falls zu eng auf kleinen Bildschirmen */
}

#gameOverText p {
  margin: 0;
  max-width: 100%;
}
    .footer {
  background-color: #009ee3;
  color: white;
  text-align: center;
  padding: 30px 20px;
  font-family: Calibri, sans-serif;
  font-size: 16px;
  font-weight: 500;
  width: 100%;
  box-sizing: border-box;
}

.footer p {
  margin: 10px 0;
}

.footer a {
  color: #fff;
  text-decoration: none;
  font-weight: bold;
  margin: 0 10px;
  display: inline-block;
}

.footer a:hover {
  text-decoration: underline;
}

@media (max-width: 480px) {
  .footer {
    font-size: 15px;
    padding: 20px 10px;
  }

  .footer a {
    display: block;
    margin: 6px 0;
  }
}
    }
    @media (max-width: 480px) {
      main {
        padding: 15px 10px;
      }
      #buttonsContainer {
        gap: 15px;
      }
      button#jumpBtn, button#homeBtn, #restartBtn {
        width: 80vw;
        max-width: 300px;
        font-size: 1.2rem;
        min-width: auto;
      }
      #arrowButtons {
        gap: 20px;
      }
      button.arrowBtn {
        width: 80px;
        height: 60px;
        font-size: 2rem;
      }
      canvas {
  width: 700px; /* oder 100% – aber nicht beides */
  height: 250px;
  display: block;
}
    }
  </style>
</head>
<body>
  <header>
    Wahlkampf Runner – Heschu Hasan 👾 Digital
  </header>

  <main>
    <h2>Spielen Sie jetzt: Wahlkampf Runner – Sammeln Sie FDP-Coins und lassen Sie die Bürokratie-Hürden hinter sich!</h2>
    <div id="introText" style="margin-top: 20px; font-size: 1.2rem; color: #333;">
      🎯 <strong>Ziel:</strong> Sammeln Sie 20 FDP-Coins, um zu gewinnen!
    </div>
    <canvas id="gameCanvas" width="700" height="250" aria-label="Spielbereich"></canvas>
    <div id="startScreen" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
  <button id="startBtn" style="font-size: 1.5rem; padding: 10px 20px;">Spiel starten</button>
</div>

    <div id="buttonsContainer" role="region" aria-label="Spielsteuerung">
      <button id="jumpBtn" aria-label="Springen Button">⤴ Springen</button>
      <div id="arrowButtons">
        <button class="arrowBtn" id="leftBtn" aria-label="Nach links gehen">◀</button>
        <button class="arrowBtn" id="rightBtn" aria-label="Nach rechts gehen">▶</button>
      </div>

      <div>
     <button id="restartBtn" aria-label="Nochmal spielen">Nochmal spielen</button>
    
      <button id="homeBtn" onclick="location.href='index.html'">Zurück zur Startseite</button>
    </div>

    <div id="gameOverText" role="alert" aria-live="assertive" tabindex="0">
  <div>
    <p>Oh nein! Verloren.</p>
    <p>Sie sollten unbedingt <strong>Heschu Hasan</strong> wählen, um die Bürokratie zu besiegen!</p>
  </div>
</div>
  </main>

  <footer style="background-color: #009ee3; color: white; text-align: center; padding: 20px 15px; font-size: 14px;">
  <p>Diese Simulation ersetzt keine politische Beratung.</p>
  <p>
    Kontakt:
    <a href="heschu.hasan@fdp-freiburg.de" style="color: white; text-decoration: underline;">heschu.hasan@fdp-freiburg.de</a> |
    Instagram:
    <a href="https://instagram.com/heschuhasan" target="_blank" style="color: white; text-decoration: underline;">@heschuhasan</a>
  </p>
  <p>&copy; 2025 Heschu Hasan 👾 Digital – FDP-Wahlkreiskandidatin</p>
</footer>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
let gameStarted = false;
const player = new Player();

jumpBtn.addEventListener("click", () => {
  jump();
});
leftBtn.addEventListener("click", () => {
  movePlayer("left");
});
rightBtn.addEventListener("click", () => {
  movePlayer("right");
});
restartBtn.addEventListener("click", () => {
  resetGame();
  gameLoop();
  restartBtn.style.display = "none";
  gameOverText.style.display = "none";
});

function gameLoop() {
  updateGame();
  draw();
  if (!gameOver) {
    requestAnimationFrame(gameLoop);
  }
}

  // Spieler-Klasse anpassen
class Player {
  constructor() {
    this.x = 50;
    this.y = 200;
    this.radius = 25;
    this.vy = 0;
    this.jumping = false;
    this.jumpStrength = -25;
    this.gravity = 0.6;

    this.image = new Image();
    this.image.src = "IMG_2350.png"; // Pfad zum Bild
    this.imageLoaded = false;

    this.image.onload = () => {
      this.imageLoaded = true;
    };
  }

  update() {
    this.vy += this.gravity;
    this.y += this.vy;

    if (this.y > groundY - this.radius) {
      this.y = groundY - this.radius;
      this.vy = 0;
      this.jumping = false;
    }
  }

  jump() {
    if (!this.jumping) {
      this.vy = this.jumpStrength;
      this.jumping = true;
    }
  }

  draw(ctx) {
    if (this.imageLoaded) {
      ctx.drawImage(this.image, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    } else {
      // Platzhalter falls Bild nicht geladen ist
      ctx.fillStyle = "#ffed00";
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }
}
// Variablen für Spielstart
const startScreen = document.getElementById("startScreen");

window.addEventListener("click", () => {
  if (!gameStarted) {
    gameStarted = true;
    startScreen.style.display = "none";  // Startbildschirm verstecken
    resetGame();
    gameLoop();
  }
});

// Überschreibe die Jump-Funktion, damit Spieler schneller hüpft
function jump() {
  if (!player.jumping && !gameOver && gameStarted) {
    player.jump();
  }
}

function drawPlayer() {
  player.draw(ctx);
}
  let score = 0;
  let gameOver = false;

  const coins = [];
  const coinSize = 20;
  let coinTimer = 0;
  const coinInterval = 90;

  const groundY = 210;

  const keys = {
    left: false,
    right: false
  };

  const gameOverText = document.getElementById("gameOverText");
  const restartBtn = document.getElementById("restartBtn");
  const jumpBtn = document.getElementById("jumpBtn");
  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  const obstacleTypes = {
    wartezeit: { icon: "⏳", text: "Wartezeit", color: "#cc3300" },
    diskussion: { icon: "💬", text: "Diskussion", color: "#ff5500" },
    formular: { icon: "📄", text: "Formular", color: "#cc3300" },
    pruefung: { icon: "❓", text: "Prüfung", color: "#cc0000" },
    ablehnung: { icon: "✖️", text: "Ablehnung", color: "#cc0000" },
    unterschrift: { icon: "🖊️", text: "Unterschrift fehlt", color: "#cc0000" }
  };

  function resetPlayer() {
    player.x = 70;
    player.y = groundY - player.radius;
    player.vy = 0;
    player.jumping = false;
  }

  function resetGame() {
    score = 0;
    gameOver = false;
    coins.length = 0;
    obstacles.length = 0;
    resetPlayer();
    gameOverText.style.display = "none";
    restartBtn.style.display = "none";
    jumpBtn.disabled = false;
    leftBtn.disabled = false;
    rightBtn.disabled = false;
  }

  const obstacles = [];

  function createObstacle() {
    const xPos = canvas.width + Math.random() * 200;
    const types = ["wartezeit", "diskussion", "formular", "pruefung", "ablehnung", "unterschrift", "sanduhr"];
    const chosenType = types[Math.floor(Math.random() * types.length)];

    if (chosenType === "sanduhr") {
      const waitTimes = ["30 Jahre", "10 Monate", "20 Wochen"];
      const waitTime = waitTimes[Math.floor(Math.random() * waitTimes.length)];
      obstacles.push({
        x: xPos,
        y: groundY,
        width: 40,
        height: 60,
        type: "sanduhr",
        waitTime: waitTime
      });
    } else {
      const o = obstacleTypes[chosenType];
      obstacles.push({
        x: xPos,
        y: groundY,
        width: 40,
        height: 60,
        type: chosenType,
        icon: o.icon,
        text: o.text,
        color: o.color
      });
    }
  }

  function drawSanduhrObstacle(x, y, width, height, waitTime) {
    ctx.save();
    ctx.fillStyle = "#e5007d";
    ctx.strokeStyle = "#c00066";
    ctx.lineWidth = 3;

    ctx.beginPath();
    ctx.moveTo(x + width / 2, y - height);
    ctx.lineTo(x, y - height / 2);
    ctx.lineTo(x + width / 2, y);
    ctx.lineTo(x + width, y - height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#ffed00";
    ctx.beginPath();
    ctx.moveTo(x + width / 4, y - 3 * height / 4);
    ctx.lineTo(x + width / 2, y - height / 2);
    ctx.lineTo(x + 3 * width / 4, y - 3 * height / 4);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(x + width / 4, y - height / 4);
    ctx.lineTo(x + width / 2, y - height / 2);
    ctx.lineTo(x + 3 * width / 4, y - height / 4);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#e5007d";
    ctx.font = "bold 16px Calibri, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(waitTime, x + width / 2, y - height - 10);

    ctx.restore();
  }

  function createCoin() {
    const xPos = canvas.width + Math.random() * 200;
    const yPos = groundY - 40 - Math.random() * 70;
    coins.push({
      x: xPos,
      y: yPos,
      width: coinSize,
      height: coinSize,
      collected: false
    });
  }

  function checkCollision(rect) {
    const playerBox = {
      x: player.x - player.radius,
      y: player.y - player.radius,
      width: player.radius * 2,
      height: player.radius * 2
    };
    return !(
      playerBox.x > rect.x + rect.width ||
      playerBox.x + playerBox.width < rect.x ||
      playerBox.y > rect.y ||
      playerBox.y + playerBox.height < rect.y - rect.height
    );
  }

  function endGame() {
    gameOver = true;
    gameOverText.style.display = "block";
    restartBtn.style.display = "inline-block";
    jumpBtn.disabled = true;
    leftBtn.disabled = true;
    rightBtn.disabled = true;
    gameOverText.focus();
  }

  function jump() {
    if (!player.jumping && !gameOver) {
      player.vy = -12;
      player.jumping = true;
    }
  }

  function movePlayer(direction) {
    if (gameOver) return;
    if (direction === "left") {
      player.x -= 15;
      if (player.x - player.radius < 0) player.x = player.radius;
    } else if (direction === "right") {
      player.x += 15;
      if (player.x + player.radius > canvas.width) player.x = canvas.width - player.radius;
    }
  }

  function updateGame() {
    if (gameOver) return;

    player.vy += player.gravity;
    player.y += player.vy;

    if (player.y > groundY - player.radius) {
      player.y = groundY - player.radius;
      player.vy = 0;
      player.jumping = false;
    }

    coinTimer++;
    if (coinTimer > coinInterval) {
      coinTimer = 0;
      createCoin();
      if (Math.random() < 0.6)createObstacle();
    }

    coins.forEach(coin => {
      coin.x -= 5;
      if (!coin.collected) {
        const dx = Math.abs(player.x - (coin.x + coin.width / 2));
        const dy = Math.abs(player.y - (coin.y + coin.height / 2));
        if (dx < player.radius + coin.width / 2 && dy < player.radius + coin.height / 2) {
          coin.collected = true;
          score++;
        }
      }
    });

    obstacles.forEach(obstacle => {
      obstacle.x -= 8;
      if (checkCollision(obstacle)) {
        endGame();
      }
    });

    if (score >= 20) {
      alert(
        "Sie haben alle FDP-Coins gesammelt.\n\n" +
        "Jeder Coin steht für eine Möglichkeit, mit mir direkt in Kontakt zu treten:\n" +
        "- z. B. durch Gespräche am Wahlkampfstand,\n" +
        "- Nachfragen auf Veranstaltungen,\n" +
        "- oder durch regelmäßigen Besuch auf meiner Seite oder meinem Instagram.\n\n" +
        "Wer sich informiert und einbringt, kann Hürden verstehen – und überwinden.\n\n" +
        "Vielen Dank für Ihr Interesse!\n\n" +
        "— Ihre Heschu Hasan"
      );
      resetGame();
    }
  }

  function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();

    ctx.fillStyle = "#000";
    const eyeRadius = 4;
    ctx.beginPath();
    ctx.arc(player.x - 7, player.y - 5, eyeRadius, 0, Math.PI * 2);
    ctx.arc(player.x + 7, player.y - 5, eyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();

    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y + 2, 10, 0, Math.PI);
    ctx.stroke();
    ctx.closePath();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#009ee3";
    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

    drawPlayer();

    obstacles.forEach(obstacle => {
      if (obstacle.type === "sanduhr") {
        drawSanduhrObstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.waitTime);
      } else {
        ctx.fillStyle = obstacle.color;
        ctx.strokeStyle = obstacle.color;
        ctx.lineWidth = 3;
        ctx.strokeRect(obstacle.x, obstacle.y - obstacle.height, obstacle.width, obstacle.height);

        ctx.font = "28px Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(obstacle.icon, obstacle.x + obstacle.width / 2, obstacle.y - obstacle.height + 40);

        ctx.font = "bold 14px Calibri, sans-serif";
        ctx.fillText(obstacle.text, obstacle.x + obstacle.width / 2, obstacle.y - obstacle.height + 60);
      }
    });

    coins.forEach(coin => {
      if (!coin.collected) {
        ctx.fillStyle = "#ffed00";
        ctx.beginPath();
        ctx.arc(coin.x + coin.width / 2, coin.y + coin.height / 2, coin.width / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();
      }
    });

    ctx.fillStyle = "#009ee3";
    ctx.font = "bold 22px Calibri, sans-serif";
    ctx.fillText("FDP-Coins: " + score + " / 20", 10, 30);
  }

  function gameLoop() {
    updateGame();
    draw();
    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    }
  }window.addEventListener("keydown", e => {
  if (["ArrowLeft", "ArrowRight", "Space", "ArrowUp"].includes(e.code)) {
    e.preventDefault();
  }

  if (gameOver || !gameStarted) return;

  if (e.code === "ArrowLeft") {
    movePlayer("left");
  } else if (e.code === "ArrowRight") {
    movePlayer("right");
  } else if (e.code === "Space" || e.code === "ArrowUp") {
    jump();
  }
});

jumpBtn.addEventListener("click", () => jump());
leftBtn.addEventListener("click", () => movePlayer("left"));
rightBtn.addEventListener("click", () => movePlayer("right"));
restartBtn.addEventListener("click", () => {
  resetGame();
  gameLoop();
});

// Verhindere mehrfaches Starten
let gameStarted = false;
startBtn.addEventListener("click", () => {
  if (!gameStarted) {
    gameStarted = true;
    startScreen.style.display = "none";
    resetGame();
    gameLoop();
  }
});

</script>
</body>
</html>
